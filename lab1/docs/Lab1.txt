1
1.1 Просто генерируем таблицы истинности.
1.2 
1.3 Генерируем случайно вектор из n элементов с 0 и 1 означающие каждую из x1..xn переменных.
Проверка, что она правда линейная получается будет в пункте 2.2.

2 
2.1 Я так и не осознал как мне в принципе задавать функцию через многочлен. Максимум что мне пришло в голову это сделать что-то вроде f = Function[{x1, x2, x3}, BitXor[x1, x2, x3 * x2]]; Однако с этим неудобно работать/либо я просто не придумал как с этим работать.
2.2 
Реализуем преобразование из таблицы истинности в АНФ с помощью рекурсивного алгоритма, который считает произведение вида
Так как 
f[x1, x2, ..., xn] = a0 + a1 * x1 + a2 * x2 + a3 * x1x2 + ... = f[0, x2, ..., xn]  + x1 * (f[0, x2, ..., xn] + f[1, x2, ..., xn])
Получаем матрицу:

[Zn-1,    0] [tmp1]
[Zn-1, Zn-1] [tmp2]

Z1 = [1, 0]
     [1, 1]
Для вектора длины 2^n
где tmp1 = верхняя половина вектора, tmp2 - нижняя.
Результатом произведения является вектор [tmp1, tmp1 xor tmp2]

Жегалкина же я получаю из АНФ просто составляя строки из бинароного представления i для коэффициента ai

2.4
То же самое что и выше просто теперь мы работаем не в поле по модулю 2 а в действительных числах, следовательно
f[x1, x2, ..., xn] = a0 + a1 * x1 + a2 * x2 + a3 * x1x2 + ... = f[0, x2, ..., xn]  + x1 * (f[0, x2, ..., xn] - f[1, x2, ..., xn])

и
[Zn-1,    0] [tmp1]
[-Zn-1, Zn-1] [tmp2]

Z1 = [1, 0]
     [-1, 1]

Для вектора длины 2^n
где tmp1 = верхняя половина вектора, tmp2 - нижняя.
Результатом произведения является вектор [tmp1, tmp2 - tmp1]

2.5
Для Адамара-Уолша мы берем вектор значений (-1)^f или же что то же самое 1 - 2 * f
умножаем его на матрицу которая так же задана рекурсивно:

[Hn-1,  Hn-1] [tmp1]
[Hn-1, -Hn-1] [tmp2]

H1 = [1, 1]
     [1, -1]


Коэффициенты Фурье получаем из коэффициентов Адамара-Уолша:
f_fourier[0, 0, ..., 0] = ||f|| = (2^n - f_hadamard[0,...,0]) / 2
А для остальных
f_fourier[a1, a2, ..., an] = -(1/2) * f_hadamard[a1, a2, ..., an]


2.6 
Я принимал за спектральные коэффициенты - коэффициенты Фурье.

Таким образом обращаем получение Фурье из А-У из предыдущего пункта. Применяем преобразование А-У и делим все на 2^n,
потому что H_n^2 = 2^n * E_n

И так как мы получили (-1)^f или же 1 - 2 f 
Обращаем эту операцию.

3
3.1
3.1.1
Та же самая проблема про задание бф как многочлена из пункта 2.1
Поэтому я просто сделал через таблицу истинности вектор функции

3.1.2 то же самое.

3.2.1 Просто разворачиваем таблицу

3.2.2
Вес - число 1 в таблице истинности
Число мономов - число 1 в векторе АНФ
Общее число мономов - число 1 в Побитовом Или векоторов АНФ всех разрядных функций

Линейный аналог - считаем коэффициенты А-У из них получаем вероятности(не обязательный шаг для сортировки)
P = 1/2 + f_hadamard / 2^(n + 1)
Итерируемся по всем векторам и ищем максимальную вероятность. Возвращаем все линейные аналоги с данной вероятностью

Действительный многочлен мы уже считали в пункте 2.4
Вероятность равенству 1 - вычисляем многочлен в точке
Степень - в векторе коэффициентов ищем индекс, вес бинарного представления которого максимален
Число мономов - считаем ненулевые элементы в векторе коэффициентов
Частные производные - то же что и вероятность но только убираем те коэффиценты в которых на i-й позиции бинарного представления - 0


3.3 
1) Если я правильно понял что мы анализируем уже Тетта функцию с помощью коэффицентов Фурье, чтобы найти наиболее вероятную комбинацию
a^T * x = b^T * F(x)
где [a, b] - индекс максимальной вероятности в полученном векторе 1/2 + O_fourier(a, b) / 2^(n + 1)
Минимальный же означает что 
a^T * x + b^T * F(x) = 1